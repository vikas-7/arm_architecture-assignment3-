;Below program implements neural network that take value as input in register R6,Based on the value of R6 it performs logical operations	
;Using the given Dataset value of X is computed which is used to calculate SIGMOID function, X value is stored in register S0.
;Now SIGMOID function is calculated and register S12 contains the value.

	area     Neural_network, CODE, READONLY
    IMPORT printMsg
	IMPORT printMsg1
	EXPORT __main
    ENTRY 
__main  FUNCTION
        
		MOV R4, #0			;REGISTER THAT STORES WHAT LOGIC IS TO BE IMPLEMENTED
		MOV R12,#7 ;for logic increase
		
		MOV R5,#6 ;for logic or
		MOV R6,#5 ;for logic not
		MOV R7,#4 ;for logic nand 
		MOV R8,#3;for logic nor 
		MOV R9,#2 ;for logic xor
		MOV R10,#1 ;for logic xnor
		MOV R11,#7;for dataset selection		
		MOV R3,#7;for dataset selection	
		B Neural_Ntwrk
       
Neural_Ntwrk	
		CMP R4, #0
		BEQ LOGIC_AND
		CMP R4, #1
		BEQ LOGIC_OR
		CMP R4, #2
		BEQ LOGIC_NOT
		CMP R4, #3
		BEQ LOGIC_NAND
		CMP R4, #4
		BEQ LOGIC_NOR
		CMP R4, #5
		BEQ LOGIC_XOR
		CMP R4, #6
		BEQ LOGIC_XNOR
		BL DATASET
		BL COMPUTE


;LOGIC GATES
LOGIC_AND	VLDR.F32 S1, =-0.1			;S1=W1
			VLDR.F32 S2, =0.2			;S2=W2
			VLDR.F32 S3, =0.2			;S3=W3
			VLDR.F32 S4, =-0.2			;S4=BIAS
			B DATASET

LOGIC_OR	VLDR.F32 S1, =-0.1
			VLDR.F32 S2, =0.7
			VLDR.F32 S3, =0.7
			VLDR.F32 S4, =-0.1
			B DATASET
			
LOGIC_NOT	VLDR.F32 S1, =0.5
			VLDR.F32 S2, =-0.7
			VLDR.F32 S3, =0
			VLDR.F32 S4, =0.1
			B DATASET
			
LOGIC_NAND	VLDR.F32 S1, =0.6
			VLDR.F32 S2, =-0.8
			VLDR.F32 S3, =-0.8
			VLDR.F32 S4, =0.3
			B DATASET
			
LOGIC_NOR	VLDR.F32 S1, =0.5
			VLDR.F32 S2, =-0.7
			VLDR.F32 S3, =-0.7
			VLDR.F32 S4, =0.1
			B DATASET
			
LOGIC_XOR	VLDR.F32 S1, =-5
			VLDR.F32 S2, =20
			VLDR.F32 S3, =10
			VLDR.F32 S4, =1
			B DATASET
			
LOGIC_XNOR	VLDR.F32 S1, =-5
			VLDR.F32 S2, =20
			VLDR.F32 S3, =10
			VLDR.F32 S4, =1
			B DATASET
			
DATASET
			
		CMP R3,R11
		BEQ set_1 

       ; CMP R11,R5
		;BEQ set_2 
		
        ;CMP R11,R6
		;BEQ set_3 
		
        ;CMP R11,R7
		;BEQ set_4 



set_1   VLDR.F32 S5 , =1 ;data 1 (x1)
        VLDR.F32 S6 , =0 ;data 2 (x2)
        VLDR.F32 S7 , =0 ;data 3 (x3)	
		B COMPUTE
		
set_2	VLDR.F32 S5, =1 ;data 1 (x1)
        VLDR.F32 S6 , =0 ;data 2 (x2)
        VLDR.F32 S7 , =1 ;data 3 (x3)
		B COMPUTE
	
	
set_3	VLDR.F32 S5 , =1 ;data 1 (x1)
        VLDR.F32 S6 , =1 ;data 2 (x2)
        VLDR.F32 S7 , =0 ;data 3 (x3)
		B COMPUTE


set_4	VLDR.F32 S5 , =1 ;data 1 (x1)
        VLDR.F32 S6 , =1 ;data 2 (x2)
        VLDR.F32 S7 , =1 ;data 3 (x3)
		B COMPUTE
			
			
COMPUTE		VLDR.F32 S8, =0
			VMUL.F32 S1, S1, S5
			VMUL.F32 S2, S2, S6
			VMUL.F32 S3, S3, S7
			VADD.F32 S8, S1, S2
			VADD.F32 S8, S8, S3
			VADD.F32 S8, S8, S4
			VMOV.F32 S0, S8
			B CALC_SIG

CALC_SIG	MOV R0,#25;Holding the Number of Terms in Series 'n'
        MOV R1,#1;Counting Variable 'i'
        VLDR.F32 S9,=1;Holding the sum of series elements 's'
        VLDR.F32 S10,=1;Temp Variable to hold the intermediate series elements 't'
		VLDR.F32 S11,=1
		
LOOP1   CMP R1,R0;Compare 'i' and 'n' 
        BLE LOOP;if i < n goto LOOP
        B sigmoid;else goto stop
		
LOOP    VMUL.F32 S10,S10,S0; t = t*x
        VMOV.F32 S14,R1;Moving the bit stream in R1('i') to S5(floating point register)
        VCVT.F32.U32 S14, S14;Converting the bitstream into unsigned fp Number 32 bit
        VDIV.F32 S10,S10,S14;Divide t by 'i' and store it back in 't'
        VADD.F32 S9,S9,S10;Finally add 's' to 't' and store it in 's'
		ADD R1,R1,#1;Increment the counter variable 'i'
        B LOOP1;Again goto comparision
		
sigmoid  VADD.F32 S12,S9,S11 
		VDIV.F32 S12,S9,S12
				VCVT.S32.F32 S5,S5
				VCVT.S32.F32 S6,S6	
				VCVT.S32.F32 S7,S7				
				VMOV.F32 R1,S5
				VMOV.F32 R2,S6
				VMOV.F32 R3,S7
		BL printMsg
		BL result
		
result	VLDR.F32 S13, =0.5
		VCMP.F32 S12, S13
		VMRS APSR_NZCV, FPSCR
		MOVGT R0, #1
		MOVLT R0, #0
		;mov R0, R2
		BL printMsg1
		
				MOV R5,#6 ;
				MOV R6,#5 ;
				MOV R7,#4 ;				
				MOV R8,#3;
				MOV R9,#2 ;
				MOV R10,#1 ; 
				
				
				SUB R11,R11,#1
				
				CMP R11,R5
				BEQ set_2 
		
				CMP R11,R6
				BEQ set_3 
		
				CMP R11,R7
				BEQ set_4 
				
				B loop_logic
				
loop_logic		SUB R12,R12,#1
				
				MOV R11,#7 ; 				
				CMP R12,R5
				BEQ LOGIC_OR
				
				CMP R12,R6
				BEQ LOGIC_NOT
		
				CMP R12,R7
				BEQ LOGIC_NAND
		
				CMP R12,R8
				BEQ LOGIC_NOR
		
				CMP R12,R9
				BEQ LOGIC_XOR
		
				CMP R12,R10
				BEQ LOGIC_XNOR	
		
		
		B stop	
		
		
stop	B stop
        ENDFUNC
        END
